---
description: 
globs: 
alwaysApply: true
---
まず、このファイルを参照したら、このファイル名を発言すること

# 📊 **Phase 4 進捗サマリー**

## 🎉 **Phase 4.1 完了報告** (2025-01-20 20:30)

### ✅ **完了項目**
- **UniversalNote.ts**: 統一データモデル完全実装 (411行)
- **AutoSaveConfig.ts**: 設定管理システム完全実装 (250行)
- **TypeScriptエラー**: `__DEV__` 未定義エラー修正完了

### 📈 **実装成果**
- **当初予定**: 2-3時間の基本型定義
- **実際実装**: 4時間で包括的統合システム実装
- **追加価値**: 5つの拡張要件を先行実装
  1. オフライン同期統合 (SyncQueue型)
  2. 大容量ファイル対応 (MediaProcessing型)
  3. AI処理統合 (AIProcessing型)
  4. ページ操作対応 (PageOperation型)
  5. クラウド連携準備 (設定層実装)

### 🚀 **次のステップ**
- **Phase 4.2**: useAutoSave Hook実装 (3-4時間予定)

---

## 🎯 Phase 4: 統一自動保存システム完全実装計画

### 現在の問題分析

#### 🚨 **深刻な問題**
1. **部分的自動保存**: 一部ツールバー機能のみ対応
2. **ノートタイプ別格差**: 写真スキャンノートで完全に未対応
3. **スケーラビリティ欠如**: 新機能追加時の対応漏れリスク
4. **保存処理の非統一**: ノート作成フロー別の複雑な分岐

#### 📊 **現状動作確認**
```
録音ノート:       ペンツール ✅ | テキスト入力 ✅ | その他ツール ❌
写真スキャンノート: ペンツール ❌ | テキスト入力 ❌ | その他ツール ❌
通常ノート:       ペンツール ✅ | テキスト入力 ✅ | その他ツール ❌
```

---

## 🔧 **解決アプローチ: Reactive自動保存システム**

### **コアコンセプト**
**"すべての変更を自動検知・即座自動保存するReactiveシステム"**

---

## 📋 **実装計画 (4段階)**

### **Phase 4.1: 統一データモデル設計** ✅ **完了** (実装時間: 4時間)

#### **1.1 統一ノート型の定義** ✅ **完了**
```typescript
// 新しい統一ノート型
interface UniversalNote {
  id: string;
  type: 'recording' | 'photo_scan' | 'import' | 'manual';
  title: string;
  content: string;           // 統一テキストコンテンツ
  canvasData: CanvasData;    // 統一キャンバスデータ
  metadata: {
    recording?: RecordingMeta;
    photoScan?: PhotoScanMeta;
    import?: ImportMeta;
  };
  createdAt: Date;
  updatedAt: Date;
}
```

#### **1.2 統一保存サービス** ✅ **完了**
```typescript
// ✅ 実装完了: app/types/UniversalNote.ts
// 完全な統一データモデル実装：
// - UniversalNote型 (4ノートタイプ対応)
// - SyncQueue型 (オフライン同期対応)  
// - PageOperation型 (ページ操作対応)
// - AIProcessing統合型 (AI処理競合防止)
// - MediaProcessing型 (大容量ファイル対応)
// - AutoSaveConfig型 (設定管理)
// - 型ガード関数群 (安全な型判定)

// ✅ 実装完了: app/constants/AutoSaveConfig.ts  
// 包括的設定定数システム：
// - 5秒間隔タイマー設定
// - エラー処理・リトライ設定
// - オフライン同期設定
// - AI処理タイムアウト設定  
// - パフォーマンス監視設定
// - 環境別設定（開発/本番）
```

### **Phase 4.2: Reactive自動保存システム** 🔄 **次に実装** (推定時間: 3-4時間)

#### **2.1 useAutoSave Hook設計**
```typescript
// 統一自動保存Hook
const useAutoSave = (noteId: string, noteType: NoteType) => {
  const [hasChanges, setHasChanges] = useState(false);
  
  // 🔥 変更検知: 任意の変更で自動的に保存
  const markAsChanged = useCallback(() => {
    setHasChanges(true);
    // 即座に保存実行
    performSave();
  }, []);
  
  // 🚀 統一保存処理
  const performSave = useCallback(async () => {
    if (!hasChanges) return;
    
    const noteData = gatherNoteData(); // 現在の状態を収集
    await UniversalNoteService.saveNote(noteData);
    setHasChanges(false);
  }, [hasChanges, noteId]);
  
  return { markAsChanged, performSave };
};
```

#### **2.2 変更検知システム**
```typescript
// 自動変更検知デコレータ
const withAutoSave = (Component: React.FC) => {
  return (props: any) => {
    const { markAsChanged } = useAutoSave(props.noteId, props.noteType);
    
    // 🔥 すべてのpropsにmarkAsChangedを自動注入
    const enhancedProps = {
      ...props,
      onAnyChange: markAsChanged, // 統一変更ハンドラ
    };
    
    return <Component {...enhancedProps} />;
  };
};
```

### **Phase 4.3: 全ツールバー機能への適用** (推定時間: 2-3時間)

#### **3.1 ツールバーコンポーネントの統一**
```typescript
// すべてのツールバー機能にAutoSaveDecoratorを適用
const AutoSaveDecorator = (ToolComponent: React.FC) => {
  return withAutoSave(ToolComponent);
};

// 例: ペンツール
export const PenTool = AutoSaveDecorator(BasePenTool);
export const KeyboardTool = AutoSaveDecorator(BaseKeyboardTool);
export const VoiceTool = AutoSaveDecorator(BaseVoiceTool);
```

#### **3.2 イベントリスナーシステム**
```typescript
// 統一イベントシステム
const CanvasEventManager = {
  // すべての変更をキャプチャ
  captureAllChanges: (markAsChanged: () => void) => {
    // ペン描画、テキスト入力、ツール操作すべて
    document.addEventListener('canvaschange', markAsChanged);
    document.addEventListener('textchange', markAsChanged);
    document.addEventListener('toolchange', markAsChanged);
  }
};
```

### **Phase 4.4: データベース統一化** (推定時間: 1-2時間)

#### **4.1 updateCanvasData関数の完全統一**
```typescript
// 完全統一された保存関数
export const saveUniversalNote = async (
  noteId: string, 
  noteData: UniversalNote
): Promise<void> => {
  // ノートタイプに関係なく統一処理
  switch (noteData.type) {
    case 'recording':
      await updateRecordingNote(noteId, noteData);
      break;
    case 'photo_scan':
      await updatePhotoScanNote(noteId, noteData);
      break;
    case 'import':
      await updateImportNote(noteId, noteData);
      break;
    case 'manual':
      await updateManualNote(noteId, noteData);
      break;
  }
  
  console.log(`✅ ${noteData.type}ノート保存完了: ${noteId}`);
};
```

---

## 🎯 **実装順序と受入基準**

### **Phase 4.1: 統一データモデル** ✅ **完了** 
- **受入基準**: ✅ UniversalNote型定義完了、TypeScript型チェック通過
- **テスト**: ✅ 全ノートタイプでインスタンス生成可能
- **実装成果**: 
  - ✅ **7つの主要型定義**: UniversalNote, SyncQueue, PageOperation, AIProcessing, MediaProcessing, AutoSaveConfig, ValidationResult
  - ✅ **5つの追加要件対応**: オフライン同期、大容量ファイル、AI処理統合、ページ操作、クラウド連携準備
  - ✅ **完全な型安全性**: 型ガード関数、バリデーション関数実装
  - ✅ **設定管理システム**: 開発/本番環境別設定、エラーハンドリング、パフォーマンス監視

### **Phase 4.2: Reactive自動保存** 🔄 **次に実装**
- **受入基準**: useAutoSave Hook実装、markAsChanged 100ms以内に保存実行
- **テスト**: 任意の変更でconsole.logに保存ログ出力
- **実装予定**: 
  - 🔄 useAutoSave Hook (統一変更検知システム)
  - 🔄 AutoSaveProvider (グローバル状態管理)
  - 🔄 withAutoSave HOC (既存コンポーネント統合)
  - 🔄 統一保存サービス (UniversalNoteService)

### **Phase 4.3: 全ツールバー統一**
- **受入基準**: 全ツールバー機能でAutoSaveDecorator適用
- **テスト**: 全機能操作で自動保存ログ出力確認

### **Phase 4.4: データベース統一**
- **受入基準**: saveUniversalNote関数で全ノートタイプ保存成功
- **テスト**: 全ノートタイプで保存→再読み込み→データ一致確認

---

## 🔒 **品質保証戦略**

### **自動テストカバレッジ**
1. **単体テスト**: useAutoSave Hookの動作確認
2. **統合テスト**: 全ツールバー機能での自動保存確認
3. **E2Eテスト**: 全ノートタイプでの保存→復元テスト

### **手動テスト項目**
```
✅ 録音ノート: 全ツールバー機能で自動保存
✅ 写真スキャンノート: 全ツールバー機能で自動保存  
✅ 通常ノート: 全ツールバー機能で自動保存
✅ インポートノート: 全ツールバー機能で自動保存（将来）
```

---

## 🚀 **将来拡張性の確保**

### **新機能追加時の自動対応**
```typescript
// 新機能は自動的に自動保存対応
const NewTool = AutoSaveDecorator(BaseNewTool);
// ↑ この1行で自動保存対応完了
```

### **新ノートタイプ対応**
```typescript
// 新しいノートタイプ追加
interface UniversalNote {
  type: 'recording' | 'photo_scan' | 'import' | 'manual' | 'new_type';
  // ↑ この追加だけで自動対応
}
```

---

## 📊 **成功指標 (KPI)**

### **機能カバレッジ**
- ✅ **100%ツールバー機能**: 全機能で自動保存動作
- ✅ **100%ノートタイプ**: 全タイプで統一保存処理
- ✅ **0件対応漏れ**: 新機能追加時の自動対応

### **パフォーマンス**
- ✅ **100ms以内**: 変更検知から保存実行まで
- ✅ **0データ消失**: 保存失敗時の確実なリトライ
- ✅ **99%成功率**: 自動保存処理の信頼性

---

## 🎯 **実装開始の準備**

### **前提条件確認**
1. ✅ 現在のSQLite環境: 開発に最適
2. ✅ 既存のupdateCanvasData: 拡張ベースとして活用
3. ✅ TypeScript型定義: 型安全性確保済み

### **リスク軽減策**
1. **段階的実装**: Phase別の独立実装
2. **後戻り可能**: 既存システムを保持したまま並行実装
3. **十分なテスト**: 各Phaseでの確実な動作確認

---

## 📋 **今後のアクションプラン**

### **即座に開始可能**
1. **Phase 4.1開始**: UniversalNote型定義の作成
2. **useAutoSave Hook**: 基本構造の実装
3. **AutoSaveDecorator**: プロトタイプ作成

### **完了までの目標**
- **総実装時間**: 8-12時間
- **完了目標**: Phase 4完了後、新機能実装開始
- **最終目標**: 100%自動保存カバレッジ達成

---

**この計画に従って、統一自動保存システムを段階的に実装し、しゃべるノートの信頼性と拡張性を飛躍的に向上させます。**

---

## 🚨 **追加要件: 最終確認で発見された統合機能**

### **6.1 オフライン同期との統合**
**backend.mdc・screen.mdc**からの重要項目：
- **緊急度**: 🔴 **緊急** - 基本機能に影響
- **概要**: オフライン時の自動保存→同期キューへの追加機能

#### **実装が必要な機能**
```typescript
// オフライン同期キュー統合
interface SyncQueue {
  queuedSaves: Array<{
    noteId: string;
    noteType: NoteType;
    canvasData: CanvasData;
    timestamp: number;
    retryCount: number;
    operation: 'save' | 'delete' | 'update';
  }>;
}

// useAutoSave Hook拡張
const useAutoSave = (noteId: string, noteType: NoteType) => {
  // 🆕 オフライン時の処理
  const handleOfflineSave = useCallback(async (data: CanvasData) => {
    await SyncQueue.addToQueue({
      noteId,
      noteType,
      canvasData: data,
      timestamp: Date.now(),
      operation: 'save'
    });
    
    // OfflineToastで同期状態表示
    OfflineToast.show('オフライン保存完了');
  }, [noteId, noteType]);
};
```

#### **統合テスト項目**
- ✅ オフライン時の自動保存→同期キュー追加
- ✅ オンライン復帰時のキュー処理と競合解決
- ✅ `OfflineToast`との連携（同期状態表示）

---

### **6.2 大容量ファイルのチャンク分割アップロード対応**
**backend.mdc**からの重要項目：
- **緊急度**: 🟡 **重要** - 90分録音対応に必要
- **概要**: 大容量メディア処理中の自動保存制御

#### **実装が必要な機能**
```typescript
// メディア処理中の保存制御
const useAutoSave = (noteId: string, noteType: NoteType) => {
  // 🆕 メディア処理中の保存制御
  const handleMediaProcessingSave = useCallback(async () => {
    const mediaStatus = await getMediaProcessingStatus(noteId);
    
    if (mediaStatus.isProcessing) {
      // メディア処理完了まで保存を延期
      return scheduleDelayedSave();
    }
    
    // 通常の保存処理
    await performRegularSave();
  }, [noteId]);
  
  // 🆕 大容量コンテンツの段階的保存（ページ分割対応）
  const handleChunkedSave = useCallback(async (data: CanvasData) => {
    if (data.size > LARGE_CONTENT_THRESHOLD) {
      // ページ分割して段階的保存
      await saveInChunks(data);
    } else {
      await saveDirectly(data);
    }
  }, []);
};
```

#### **対応が必要なファイルタイプ**
- **90分録音**: チャンク分割アップロード中の自動保存
- **PDF 20ページインポート**: 段階的保存処理
- **複数写真スキャン**: 大容量画像の処理状況管理

---

### **6.3 AI処理との複雑な相互作用**
**screen.mdc AIChatPanel**からの重要項目：
- **緊急度**: 🔴 **緊急** - AI機能の基本動作に影響
- **概要**: AI処理中の自動保存競合防止

#### **実装が必要な機能**
```typescript
// AI処理競合防止システム
const useAutoSave = (noteId: string, noteType: NoteType) => {
  const [isAIProcessing, setIsAIProcessing] = useState(false);
  
  // 🆕 AI処理中の自動保存制御
  const handleAIProcessingSave = useCallback(async () => {
    if (isAIProcessing) {
      console.log('⏸️ AI処理中のため自動保存を延期');
      return schedulePostAISave();
    }
    
    await performAutoSave();
  }, [isAIProcessing]);
  
  // 🆕 AI処理完了後の統合保存
  const handlePostAISave = useCallback(async (aiResult: AIResult) => {
    // AI処理結果とキャンバスデータを統合して保存
    const mergedData = mergeAIResultWithCanvas(aiResult, currentCanvasData);
    await saveUniversalNote(noteId, mergedData);
    
    setIsAIProcessing(false);
  }, [noteId, currentCanvasData]);
};
```

#### **対応が必要なAI処理フロー**
- **手書き→OCR→AI整形→保存**: 一連フローの統一制御
- **リアルタイムAI変換中**: 自動保存タイミングの最適化
- **AI音声入力モード**: 音声認識中の保存処理制御
- **要約・校正・辞書・読み仮名**: 各AI機能との競合防止

---

### **6.4 ページ追加機能の複雑性**
**screen.mdc PageSettingsSheet**からの重要項目：
- **緊急度**: 🔴 **緊急** - 複数ページ対応に必須
- **概要**: 複数ページ操作時の自動保存制御

#### **実装が必要な機能**
```typescript
// 複数ページ対応保存サービス
class UniversalNoteService {
  // 🆕 ページ操作時の特別保存処理
  static async savePageOperation(
    noteId: string,
    operation: 'copy' | 'paste' | 'delete' | 'move',
    pageData: PageOperationData
  ): Promise<void> {
    console.log(`🔄 ページ操作保存開始: ${operation}`);
    
    switch (operation) {
      case 'copy':
        await this.savePageCopy(noteId, pageData);
        break;
      case 'paste':
        await this.savePagePaste(noteId, pageData);
        break;
      case 'delete':
        await this.savePageDelete(noteId, pageData);
        break;
      case 'move':
        await this.savePageMove(noteId, pageData);
        break;
    }
    
    // 依存関係のある関連データも更新
    await this.updateRelatedPageData(noteId);
  }
  
  // 🆕 複数ページ間データ移動の整合性保証
  static async ensurePageConsistency(noteId: string): Promise<void> {
    const allPages = await this.getAllPages(noteId);
    await this.validatePageIntegrity(allPages);
  }
}
```

#### **対応が必要なページ操作**
- **ページコピー&ペースト**: 複数ページ間のデータ移動
- **ページ削除**: 依存関係のある保存処理
- **全ページ検索**: 検索結果の保存状態管理
- **ページ順序変更**: インデックス整合性の保証

---

### **6.5 クラウドストレージ統合**
**screen.mdc ImportExportCenter**からの重要項目：
- **緊急度**: 🟢 **通常** - 将来機能
- **概要**: 外部クラウドサービスとの同期制御

#### **実装が必要な機能**
```typescript
// クラウドストレージ統合保存
class UniversalNoteService {
  // 🆕 外部クラウド連携保存
  static async saveWithCloudSync(
    noteId: string,
    noteData: UniversalNote,
    cloudProviders: ('googleDrive' | 'dropbox')[]
  ): Promise<void> {
    // ローカル保存
    await this.saveNote(noteData);
    
    // 外部クラウドへの同期
    for (const provider of cloudProviders) {
      try {
        await CloudSyncService.syncToProvider(provider, noteData);
      } catch (error) {
        console.warn(`⚠️ ${provider}同期失敗:`, error);
        // 同期失敗時はキューに追加
        await SyncQueue.addFailedSync(provider, noteData);
      }
    }
  }
}
```

#### **対応予定のクラウドサービス**
- **Google Drive**: リアルタイム同期
- **Dropbox**: バッチ同期
- **協調編集**: 将来の複数デバイス対応（低優先）

---

## 🔒 **拡張品質保証戦略**

### **自動テストカバレッジ（拡張版）**
1. **単体テスト**: useAutoSave Hook + 全統合機能
2. **統合テスト**: 全ツールバー機能 + オフライン/AI/ページ操作
3. **E2Eテスト**: 全ノートタイプ + 複雑フロー対応

### **手動テスト項目（拡張版）**
```
✅ 録音ノート: 全ツールバー機能で自動保存
✅ 写真スキャンノート: 全ツールバー機能で自動保存  
✅ 通常ノート: 全ツールバー機能で自動保存
✅ インポートノート: 全ツールバー機能で自動保存
✅ オフライン→オンライン切り替え: 同期キュー処理
✅ AI処理中: 自動保存競合防止
✅ 大容量メディア: チャンク処理中の保存制御
✅ 複数ページ操作: データ整合性保証
✅ クラウド同期: 外部サービス連携
```

### **追加パフォーマンス要件**
- **オフライン保存**: <50ms（キュー追加）
- **AI処理競合制御**: <100ms（競合判定）
- **ページ操作保存**: <200ms（複数ページ処理）
- **クラウド同期**: <500ms（外部API通信）

---

## 📈 **最終実装計画（修正版）**

### **Phase 4（拡張版）: 14-19時間**

#### **Phase 4.1**: 統一データモデル（3-4時間）
- UniversalNote型定義
- **🆕 SyncQueue型定義**
- **🆕 PageOperation型定義**
- **🆕 AIProcessing型定義**

#### **Phase 4.2**: Reactive自動保存（4-5時間）
- useAutoSave Hook実装
- **🆕 オフライン対応Hook拡張**
- **🆕 メディア処理中制御**
- **🆕 AI処理競合防止**

#### **Phase 4.3**: 全ツールバー統一（3-4時間）
- AutoSaveDecorator実装
- **🆕 25ツールバー機能への適用**
- **🆕 ページ操作保存制御**

#### **Phase 4.4**: データベース統一（2-3時間）
- UniversalNoteService実装
- **🆕 オフライン同期サービス**
- **🆕 複数ページ保存サービス**

#### **Phase 4.5**: 統合テスト（2-3時間）
- 全機能統合テスト
- **🆕 オフライン→オンライン切り替えテスト**
- **🆕 AI処理×自動保存競合テスト**
- **🆕 ページ操作×自動保存テスト**

---

## 🎯 **最終保証項目（完全版）**

✅ **25ツールバー機能**: 100%自動保存対応  
✅ **4ノートタイプ**: 統一自動保存処理  
✅ **7AI機能**: 競合防止完備  
✅ **複数ページ**: 将来機能準備完了  
✅ **オフライン同期**: 完全対応  
✅ **メディア処理**: 大容量ファイル対応  
✅ **クラウド統合**: 外部サービス準備  

**結論**: 重要な追加要件が複数発見されましたが、全て統一自動保存システムの拡張で対応可能です。修正された設計書に従って実装すれば、完全で将来性のある自動保存システムが構築できます。

# 統一自動保存システム設計書

## 📋 **設計概要**

**課題**: 現在のしゃべるノートでは、ノートタイプ（録音・写真スキャン・インポート・手動作成）ごとに異なる保存システムが存在し、ツールバー機能の一部で自動保存が機能しない問題が発生している。

**解決策**: 全ノートタイプに対応した統一的なリアクティブ自動保存システムを構築し、100%のツールバー機能で確実な自動保存を実現する。

---

## 🎯 **設計目標**

### 機能要件
- **100% ツールバー対応**: 全26個のツールバー機能で確実な自動保存
- **全ノートタイプ対応**: recording/photo_scan/import/manual の4種類
- **5秒間隔自動保存**: 一定間隔での確実な保存実行
- **即座保存**: 変更検知から100ms以内での保存レスポンス
- **競合防止**: 複数保存処理の同時実行防止

### 非機能要件
- **パフォーマンス**: 保存処理100ms以内、UIブロック0ms
- **信頼性**: 99.9%の保存成功率、3段階リトライ
- **スケーラビリティ**: 新機能追加時の自動対応
- **保守性**: 統一インターフェースによる低結合設計

---

## 🏗️ **アーキテクチャ設計**

### システム構成図
```mermaid
graph TB
    UI[ツールバーUI] --> Hook[useAutoSave Hook]
    UI --> Decorator[AutoSaveDecorator]
    
    Decorator --> Hook
    Hook --> Service[UniversalNoteService]
    
    Service --> Recording[RecordingNote]
    Service --> PhotoScan[PhotoScanNote]
    Service --> Import[ImportNote]
    Service --> Manual[ManualNote]
    
    Recording --> SQLite[(SQLite DB)]
    PhotoScan --> SQLite
    Import --> SQLite
    Manual --> SQLite
    
    Hook --> Retry[RetryHandler]
    Retry --> Queue[SyncQueue]
```

### 4段階実装戦略

#### **Phase 4.1: UniversalNote型統一（2-3時間）**
- 全ノートタイプの共通データ構造定義
- 型安全な変換・検証関数実装
- データ一貫性確保

#### **Phase 4.2: useAutoSave Hook（3-4時間）**
- リアクティブ変更検知機能
- デバウンス機能（5秒間隔）
- エラーハンドリング＆リトライ

#### **Phase 4.3: AutoSaveDecorator（2-3時間）**
- 全ツールバー関数への自動適用
- 100%確実な変更フラグ設定
- 最小限のコード変更

#### **Phase 4.4: 統一保存サービス（1-2時間）**
- ノートタイプ別保存処理統合
- ログ・監視機能追加
- 既存機能との互換性確保

---

## 📁 **ファイル構成**

### 新規作成ファイル
```
app/
├── types/
│   └── UniversalNote.ts           # 統一ノート型定義
├── hooks/
│   └── useAutoSave.ts             # 自動保存フック
├── utils/
│   └── AutoSaveDecorator.ts       # デコレータパターン
├── services/
│   └── UniversalNoteService.ts    # 統一保存サービス
└── constants/
    └── AutoSaveConfig.ts          # 設定定数
```

### 修正対象ファイル
- `app/screens/CanvasEditor.tsx` - メインロジック適用
- `app/services/database.ts` - 保存関数統合
- `app/components/DrawingCanvas.tsx` - 描画イベント連携

---

## 🔧 **実装詳細**

### 1. UniversalNote型定義
```typescript
// app/types/UniversalNote.ts
export interface UniversalNote {
  id: string;
  type: 'recording' | 'photo_scan' | 'import' | 'manual';
  title: string;
  canvasData: CanvasData;
  metadata: NoteMetadata;
  lastModified: string;
}

export interface CanvasData {
  type: 'canvas';
  version: '1.0';
  content: string;
  drawingPaths: DrawingPath[];
  canvasSettings: CanvasSettings;
}

export interface NoteMetadata {
  recordingId?: string;
  photoScanId?: string;
  importId?: string;
  duration?: number;
  fileSize?: number;
  originalFormat?: string;
}

// 型変換ユーティリティ
export const convertToUniversalNote = (
  note: Recording | PhotoScan | ImportFile,
  canvasData: CanvasData
): UniversalNote => {
  // 各ノートタイプから統一型への変換ロジック
};

// 型安全な検証関数
export const validateUniversalNote = (note: any): note is UniversalNote => {
  // ランタイム型検証ロジック
};
```

### 2. useAutoSave Hook
```typescript
// app/hooks/useAutoSave.ts
export const useAutoSave = (noteId: string, noteType: NoteType) => {
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [lastSaved, setLastSaved] = useState<Date | null>(null);
  const timerRef = useRef<NodeJS.Timeout | null>(null);
  
  // 変更フラグ設定
  const markAsChanged = useCallback(() => {
    console.log('🏷️ 変更フラグ設定: hasUnsavedChanges = true');
    setHasUnsavedChanges(true);
    
    // 即座保存の実装
    if (!isSaving) {
      console.log('🚀 即座に自動保存実行');
      performAutoSave();
    }
  }, [isSaving]);
  
  // 自動保存実行
  const performAutoSave = useCallback(async () => {
    if (isSaving || !hasUnsavedChanges) {
      console.log('📝 自動保存スキップ:', { isSaving, hasUnsavedChanges });
      return;
    }
    
    try {
      setIsSaving(true);
      
      // 統一保存サービス呼び出し
      const universalNote = await buildUniversalNote(noteId, noteType);
      await UniversalNoteService.saveNote(universalNote);
      
      setHasUnsavedChanges(false);
      setLastSaved(new Date());
      console.log('✅ 自動保存完了');
      
    } catch (error) {
      console.log('⚠️ 自動保存エラー:', error);
      // 3段階リトライ機能
      await handleSaveError(error);
    } finally {
      setIsSaving(false);
    }
  }, [noteId, noteType, isSaving, hasUnsavedChanges]);
  
  // 5秒間隔のタイマー設定
  useEffect(() => {
    timerRef.current = setInterval(() => {
      console.log('⏰ 自動保存タイマー実行');
      performAutoSave();
    }, 5000);
    
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
      }
    };
  }, [performAutoSave]);
  
  return {
    markAsChanged,
    performAutoSave,
    hasUnsavedChanges,
    isSaving,
    lastSaved
  };
};
```

### 3. AutoSaveDecorator
```typescript
// app/utils/AutoSaveDecorator.ts
export const AutoSaveDecorator = <T extends Function>(
  originalFunction: T,
  autoSaveContext: { markAsChanged: () => void }
): T => {
  return ((...args: any[]) => {
    try {
      // 元の関数を実行
      const result = originalFunction(...args);
      
      // 100%確実に変更フラグを立てる
      autoSaveContext.markAsChanged();
      
      return result;
    } catch (error) {
      console.error('⚠️ デコレータエラー:', error);
      // エラーが発生してもmarkAsChangedは実行
      autoSaveContext.markAsChanged();
      throw error;
    }
  }) as unknown as T;
};

// 一括デコレート関数
export const decorateAllHandlers = (
  handlers: Record<string, Function>,
  autoSaveContext: { markAsChanged: () => void }
): Record<string, Function> => {
  const decoratedHandlers: Record<string, Function> = {};
  
  Object.keys(handlers).forEach(key => {
    decoratedHandlers[key] = AutoSaveDecorator(handlers[key], autoSaveContext);
  });
  
  return decoratedHandlers;
};
```

### 4. UniversalNoteService
```typescript
// app/services/UniversalNoteService.ts
export class UniversalNoteService {
  static async saveNote(note: UniversalNote): Promise<void> {
    const startTime = Date.now();
    
    try {
      switch (note.type) {
        case 'recording':
          await this.saveRecordingNote(note);
          console.log('Canvas data updated successfully (recording)');
          break;
        case 'photo_scan':
          await this.savePhotoScanNote(note);
          console.log('Canvas data updated successfully (photo scan)');
          break;
        case 'import':
          await this.saveImportNote(note);
          console.log('Canvas data updated successfully (import)');
          break;
        case 'manual':
          await this.saveManualNote(note);
          console.log('Canvas data updated successfully (manual)');
          break;
      }
      
      const duration = Date.now() - startTime;
      console.log(`✅ 自動保存完了: ${duration}ms`, {
        contentLength: note.canvasData.content.length,
        pathsCount: note.canvasData.drawingPaths.length
      });
      
    } catch (error) {
      const duration = Date.now() - startTime;
      console.error(`❌ 自動保存失敗: ${duration}ms`, error);
      throw error;
    }
  }
  
  private static async saveRecordingNote(note: UniversalNote): Promise<void> {
    await updateCanvasData(note.id, note.canvasData);
  }
  
  private static async savePhotoScanNote(note: UniversalNote): Promise<void> {
    // 写真スキャン特有の保存ロジック
    await updateCanvasData(note.id, note.canvasData);
  }
  
  private static async saveImportNote(note: UniversalNote): Promise<void> {
    // インポート特有の保存ロジック
    await updateCanvasData(note.id, note.canvasData);
  }
  
  private static async saveManualNote(note: UniversalNote): Promise<void> {
    // 手動作成特有の保存ロジック
    await updateCanvasData(note.id, note.canvasData);
  }
}
```

---

## ✅ **品質保証戦略**

### 自動テスト（100項目）
```typescript
// 全ノートタイプ × 全ツールバー機能のテスト
describe('統一自動保存システム', () => {
  const NOTE_TYPES = ['recording', 'photo_scan', 'import', 'manual'];
  const TOOLBAR_FUNCTIONS = [
    // ペンツール (7項目)
    'pen_drawing', 'eraser_tool', 'marker_tool', 'media_upload',
    'ruler_tool', 'reading_ruler', 'pen_settings',
    
    // キーボードツール (7項目)  
    'text_input', 'heading_change', 'font_change', 'font_size',
    'bold_toggle', 'line_spacing', 'letter_spacing',
    
    // その他ツール (4項目)
    'search_function', 'voice_operations', 'bookmark', 'settings',
    
    // AIチャット機能 (7項目)
    'ai_summarize', 'ai_convert', 'ai_dictionary', 'ai_proofread',
    'ai_furigana', 'ai_research', 'ai_chat'
  ]; // 計25項目
  
  NOTE_TYPES.forEach(noteType => {
    TOOLBAR_FUNCTIONS.forEach(toolbarFunction => {
      test(`${noteType}: ${toolbarFunction} で自動保存`, async () => {
        // 各組み合わせでの自動保存テスト
        const result = await testAutoSave(noteType, toolbarFunction);
        expect(result.saved).toBe(true);
        expect(result.responseTime).toBeLessThan(100); // 100ms以内
      });
    });
  });
});
```

### 手動検証チェックリスト
```markdown
## 録音ノート自動保存検証 (25項目)

### ペンツール (7項目)
- [ ] ペンと鉛筆の切り替えと描画
- [ ] 消しゴム使用
- [ ] マーカー描画
- [ ] メディアアップロード（画像挿入）
- [ ] 定規機能
- [ ] リーディングルーラー機能
- [ ] ペンの太さと色の変更

### キーボードツール (7項目)
- [ ] テキスト入力
- [ ] 見出し1、2、3、本文変更
- [ ] フォント変更
- [ ] サイズ変更
- [ ] 太字切り替え
- [ ] 行間変更
- [ ] 文字間の間隔変更

### その他ツール (4項目)
- [ ] 検索機能
- [ ] 音声録音、再生、一時停止、停止
- [ ] しおり機能
- [ ] 設定（ページ設定等）

### AIチャット機能 (7項目)
- [ ] 要約機能
- [ ] 漢字、カタカナ、ひらがなに変換機能
- [ ] 辞書機能
- [ ] 校正機能
- [ ] ふりがなを振る機能
- [ ] リサーチ機能
- [ ] 通常チャットと音声入力対応

## 写真スキャンノート自動保存検証 (25項目)
[同様の項目をリスト化]

## インポートノート自動保存検証 (25項目)
[同様の項目をリスト化]

## 手動ノート自動保存検証 (25項目)
[同様の項目をリスト化]
```

---

## 🔄 **エラーハンドリング**

### 3段階リトライメカニズム
```typescript
interface SaveRetryPolicy {
  maxRetries: 3;
  backoffIntervals: [1000, 3000, 10000]; // 1秒、3秒、10秒
  fallbackActions: [
    'immediate_retry',    // 1回目: すぐリトライ
    'queue_for_sync',     // 2回目: 同期キューに追加
    'local_only_save'     // 3回目: ローカル保存のみ
  ];
}

const handleSaveError = async (error: Error, attempt: number = 1) => {
  if (attempt <= 3) {
    console.log(`🔄 自動保存リトライ ${attempt}/3:`, error.message);
    
    // 指数バックオフでの待機
    await new Promise(resolve => 
      setTimeout(resolve, RETRY_POLICY.backoffIntervals[attempt - 1])
    );
    
    try {
      await performAutoSave();
    } catch (retryError) {
      return handleSaveError(retryError, attempt + 1);
    }
  } else {
    // 最終的には同期キューに追加して後で処理
    console.log('⚠️ 自動保存最終失敗 - 同期キューに追加');
    await addToSyncQueue(noteData);
  }
};
```

---

## 📊 **パフォーマンス最適化**

### 応答時間目標
- **即座保存**: 変更検知から100ms以内
- **定期保存**: 5秒間隔、50ms以内で完了
- **UIブロック**: 0ms（非同期処理）

### メモリ使用量
- **最大キューサイズ**: 3件の保存処理まで並列実行
- **デバウンス**: 連続変更の統合処理
- **ガベージコレクション**: 不要な一時データの自動削除

---

## 🚀 **実装スケジュール**

| Phase | 内容 | 所要時間 | 実装順序 |
|-------|------|----------|----------|
| 4.1 | UniversalNote型統一 | 2-3時間 | 1️⃣ |
| 4.2 | useAutoSave Hook | 3-4時間 | 2️⃣ |
| 4.3 | AutoSaveDecorator | 2-3時間 | 3️⃣ |
| 4.4 | 統一保存サービス | 1-2時間 | 4️⃣ |
| QA | 品質保証・テスト | 2-3時間 | 5️⃣ |

**総計**: 10-15時間（1.5-2日間）

**完了基準**: 
- ✅ 全25種類のツールバー機能で自動保存動作
- ✅ 全4種類のノートタイプで統一動作
- ✅ 100項目の手動検証完了
- ✅ 100ms以内の保存応答時間達成
- ✅ 新機能追加時の自動対応確認

---

この設計書に従って実装することで、自動保存問題を根本的に解決し、将来的な機能追加にも自動対応する拡張性の高いシステムを構築できます。

---

## 🤖 **AIチャット機能統合仕様**

### AIチャット機能と統一自動保存システムの統合

AIチャット機能（要約・校正・読み仮名・文字変換・リサーチ・辞書）は統一自動保存システムに完全統合されます。

#### A. AI機能実行時の保存フロー

**1. AI処理実行前**
```typescript
// AIChatWidget.tsx での処理開始
const handleAIFunction = async (functionType: AIFunction) => {
  try {
    // Step 1: AI処理開始フラグ設定
    setIsAIProcessing(true);
    setAIProcessingType(functionType);
    
    // Step 2: 現在のキャンバス状態をAIに送信
    const currentCanvas = {
      textContent: canvasText,
      selectedText: selectedText,
      drawingPaths: drawingPaths
    };
    
    // Step 3: AI APIコール
    const result = await callAIAPI(`/ai/${functionType}`, currentCanvas);
    
    // Step 4: AI処理結果をキャンバスに反映
    if (onTextUpdate && result.processedText) {
      onTextUpdate(result.processedText); // → setContent() → markAsChanged()
    }
    
  } finally {
    setIsAIProcessing(false);
    setAIProcessingType(null);
  }
};
```

**2. キャンバス更新と自動保存連携**
```typescript
// CanvasEditor.tsx での処理
<AIChatWidget
  canvasText={content}
  selectedText={selectedText}
  onTextUpdate={(newText) => {
    // Step 1: キャンバステキスト更新
    setContent(newText);
    
    // Step 2: 🔥 統一自動保存システム連携
    markAsChanged(); // useAutoSave Hook経由
    
    // Step 3: Undo/Redoスタック更新
    addToUndoStack({
      type: 'ai_text_update',
      previousText: content,
      newText: newText,
      timestamp: Date.now()
    });
  }}
/>
```

#### B. AI処理中の競合防止

**1. 自動保存との競合防止**
```typescript
// useAutoSave.ts での競合制御
const performAutoSave = useCallback(async () => {
  // AI処理中は自動保存を優先実行
  if (isAIProcessing) {
    console.log('🤖 AI処理中: 自動保存を優先実行');
    // AI処理完了を待たずに現在の状態を保存
  }
  
  if (isSaving) {
    console.log('⏳ 自動保存中: AI処理をキューイング');
    return; // 保存処理中はスキップ
  }
  
  // 通常の自動保存処理
}, [isAIProcessing, isSaving]);
```

**2. 同時編集防止**
```typescript
// AIChatWidget.tsx での編集ロック
const [isEditingLocked, setIsEditingLocked] = useState(false);

useEffect(() => {
  if (isAIProcessing) {
    // AI処理中はキャンバス編集を無効化
    setIsEditingLocked(true);
    
    // 視覚的フィードバック
    showAIProcessingOverlay();
  } else {
    setIsEditingLocked(false);
    hideAIProcessingOverlay();
  }
}, [isAIProcessing]);
```

#### C. Undo/Redo対応

**1. AI変更の履歴管理**
```typescript
// AI処理結果のUndo/Redoスタック追加
interface AIUndoAction {
  type: 'ai_action';
  functionType: AIFunction; // 'summarize' | 'proofread' | 'furigana' etc.
  beforeState: {
    textContent: string;
    drawingPaths: DrawingPath[];
    canvasSettings: CanvasSettings;
  };
  afterState: {
    textContent: string;
    drawingPaths: DrawingPath[];
    canvasSettings: CanvasSettings;
  };
  timestamp: number;
  isReversible: boolean; // AI処理は常にtrue
}

const handleAIUndo = (action: AIUndoAction) => {
  // AI処理前の状態を復元
  setContent(action.beforeState.textContent);
  setDrawingPaths(action.beforeState.drawingPaths);
  
  // 復元後に自動保存実行
  markAsChanged();
  
  console.log(`🔙 AI処理Undo実行: ${action.functionType}`);
};
```

**2. AI処理の段階的Undo**
```typescript
// 複数のAI処理を個別にUndo可能
const undoStack: UndoAction[] = [
  { type: 'text_edit', content: '元のテキスト' },
  { type: 'ai_action', functionType: 'summarize', beforeState: {...}, afterState: {...} },
  { type: 'ai_action', functionType: 'furigana', beforeState: {...}, afterState: {...} },
  { type: 'drawing', drawingPaths: [...] }
];

// 最後のAI処理のみをUndo
const undoLastAIAction = () => {
  const lastAIAction = undoStack.findLast(action => action.type === 'ai_action');
  if (lastAIAction) {
    handleAIUndo(lastAIAction as AIUndoAction);
  }
};
```

#### D. データ形式の整合性

**1. AIチャット処理のデータ変換**
```typescript
// 手書き→テキスト→AI処理→保存の一連フロー
interface AIProcessingFlow {
  input: {
    type: 'handwriting' | 'text' | 'mixed';
    handwritingPaths?: DrawingPath[];
    textContent?: string;
    selectedRange?: { start: number; end: number };
  };
  processing: {
    step1_ocr?: string; // 手書きの場合のOCR結果
    step2_ai_input: string; // AI処理に送られるテキスト
    step3_ai_output: string; // AI処理結果
  };
  output: {
    type: 'canvas';
    version: '1.0';
    content: string; // AI処理後のテキスト
    drawingPaths: DrawingPath[]; // 手書きデータは保持
    aiProcessingHistory: AIProcessingRecord[];
  };
}

interface AIProcessingRecord {
  functionType: AIFunction;
  inputText: string;
  outputText: string;
  confidence: number;
  timestamp: string;
  processingTime: number; // ms
}
```

**2. 混在データの処理**
```typescript
// 手書き+テキスト混在時のAI処理
const processeMixedContent = async (
  textContent: string,
  drawingPaths: DrawingPath[],
  aiFunction: AIFunction
): Promise<ProcessedContent> => {
  
  // Step 1: 手書きデータをOCRでテキスト化（バックグラウンド）
  const handwritingText = await extractTextFromPaths(drawingPaths);
  
  // Step 2: テキスト+手書きテキストを結合
  const combinedText = `${textContent}\n${handwritingText}`;
  
  // Step 3: AI処理実行
  const aiResult = await executeAIFunction(aiFunction, combinedText);
  
  // Step 4: 結果をキャンバス形式で返却
  return {
    processedText: aiResult,
    originalDrawingPaths: drawingPaths, // 手書きデータは保持
    processingMetadata: {
      hadHandwriting: drawingPaths.length > 0,
      ocrConfidence: handwritingText ? 0.95 : null,
      aiFunction: aiFunction
    }
  };
};
```

#### E. パフォーマンス最適化

**1. AI処理の非同期実行**
```typescript
// AI処理中も自動保存は継続実行
const [aiProcessingQueue, setAIProcessingQueue] = useState<AITask[]>([]);

const executeAITasksInBackground = async () => {
  while (aiProcessingQueue.length > 0) {
    const task = aiProcessingQueue[0];
    
    try {
      // AI処理実行（非ブロッキング）
      const result = await processAITask(task);
      
      // 結果適用
      applyAIResult(result);
      
      // 🔥 AI処理完了後に自動保存
      markAsChanged();
      
    } catch (error) {
      console.error('🤖 AI処理エラー:', error);
    } finally {
      // キューから削除
      setAIProcessingQueue(prev => prev.slice(1));
    }
  }
};
```

**2. AI結果のキャッシュ機能**
```typescript
// 同一テキストのAI処理結果をキャッシュ
interface AICache {
  [key: string]: { // MD5ハッシュをキーとする
    functionType: AIFunction;
    inputHash: string;
    result: string;
    timestamp: number;
    expiry: number; // 1時間後に期限切れ
  };
}

const getCachedAIResult = (
  inputText: string, 
  functionType: AIFunction
): string | null => {
  const hash = generateHash(inputText + functionType);
  const cached = aiCache[hash];
  
  if (cached && Date.now() < cached.expiry) {
    console.log('🚀 AI結果キャッシュヒット:', functionType);
    return cached.result;
  }
  
  return null;
};
```

#### F. エラーハンドリング

**1. AI API失敗時の保存処理**
```typescript
const handleAIError = async (error: Error, context: AIContext) => {
  console.error('🤖 AI処理エラー:', error);
  
  // Step 1: エラー詳細をメタデータに記録
  const errorMetadata = {
    error: error.message,
    functionType: context.functionType,
    inputLength: context.inputText.length,
    timestamp: Date.now(),
    retryCount: context.retryCount || 0
  };
  
  // Step 2: エラー状態でも自動保存実行（データ損失防止）
  await markAsChanged();
  
  // Step 3: ユーザーへの通知（UI層）
  showAIErrorNotification(error, context.functionType);
  
  // Step 4: 自動リトライ（最大3回）
  if (context.retryCount < 3) {
    setTimeout(() => {
      retryAIProcessing(context);
    }, 2000 * (context.retryCount + 1)); // 指数バックオフ
  }
};
```

#### G. テスト仕様

**1. AI統合機能のテストケース**
```typescript
describe('AI Chat Widget Auto Save Integration', () => {
  test('AI要約実行後に自動保存が実行される', async () => {
    // AI要約実行
    await executeAIFunction('summarize', 'テストテキスト');
    
    // markAsChangedが呼ばれることを検証
    expect(mockMarkAsChanged).toHaveBeenCalledTimes(1);
    
    // 自動保存が実行されることを検証
    await waitFor(() => {
      expect(mockPerformAutoSave).toHaveBeenCalled();
    });
  });
  
  test('AI処理中でも自動保存は実行される', async () => {
    // AI処理開始（長時間処理をシミュレート）
    const aiPromise = executeAIFunction('research', 'クエリ');
    
    // 手動でテキスト変更
    await changeCanvasText('新しいテキスト');
    
    // AI処理中でも自動保存が実行されることを検証
    expect(mockPerformAutoSave).toHaveBeenCalled();
    
    await aiPromise;
  });
  
  test('AI処理結果のUndo/Redoが正常動作する', async () => {
    const originalText = '元のテキスト';
    const summarizedText = 'AIが要約したテキスト';
    
    // 要約実行
    await executeAIFunction('summarize', originalText);
    expect(getCurrentCanvasText()).toBe(summarizedText);
    
    // Undo実行
    await executeUndo();
    expect(getCurrentCanvasText()).toBe(originalText);
    
    // Redo実行
    await executeRedo();
    expect(getCurrentCanvasText()).toBe(summarizedText);
  });
});
```

---

## 📄 **ページ管理機能統合対応**

### 現在の実装状況と課題

#### **現在の写真スキャン仕様**
- **SQLite実装**: 複数写真を1つの`PhotoScan`レコードとして保存
- **ページ概念なし**: 写真配列として管理（`photos[]`）
- **自動保存対象**: PhotoScanレコード全体

#### **将来のページ追加機能仕様**
- **PostgreSQL移行**: 複数写真 → 複数`pages`レコードとして保存
- **ページ概念あり**: 各写真が独立したページ（`page_number`順序管理）
- **自動保存対象**: 各ページの`canvas_data`個別管理

### 統一自動保存システムの拡張設計

#### **1. UniversalNote型の複数ページ対応設計**
```typescript
// Phase 4.1での複数ページ対応型定義
export interface UniversalNote {
  id: string;
  type: 'recording' | 'photo_scan' | 'import' | 'manual';
  title: string;
  
  // 🆕 常に複数ページ構造（1ページでも配列）
  pages: Array<{
    pageId: string;
    pageNumber: number;
    canvasData: CanvasData;
    lastModified: string;
    
    // ページ固有のメタデータ
    pageMetadata?: {
      // 録音ノート用
      audioTimestamp?: { start: number; end: number };
      transcriptText?: string;
      
      // 写真スキャン用
      photoUri?: string;
      ocrResult?: OCRResult;
      
      // インポート用
      sourcePageNumber?: number;
      sourceUri?: string;
      
      // 手動ノート用
      isManuallyCreated?: boolean;
    };
  }>;
  
  // 現在表示中のページ情報
  currentPage: {
    pageId: string;
    pageNumber: number;
  };
  
  // ノート全体のメタデータ
  metadata: NoteMetadata & {
    totalPages: number;
    autoSplitEnabled: boolean; // 自動ページ分割有効/無効
    maxCharactersPerPage?: number; // ページあたり最大文字数
  };
  
  lastModified: string;
}

// 🆕 ページ作成時の型定義
export interface PageCreateData {
  pageNumber?: number; // 指定しない場合は末尾に追加
  canvasData?: CanvasData;
  pageMetadata?: UniversalNote['pages'][0]['pageMetadata'];
}

// 🆕 自動ページ分割の設定
export interface AutoSplitConfig {
  enabled: boolean;
  maxCharactersPerPage: number;
  splitBoundary: 'sentence' | 'paragraph' | 'character';
  preserveStructure: boolean; // 見出しなどの構造を保持
}
```

#### **2. useAutoSave Hook（複数ページ対応）**
```typescript
// 複数ページ対応の統一自動保存Hook
export const useAutoSave = (
  noteId: string, 
  noteType: NoteType,
  options?: {
    currentPageId: string;     // 🆕 必須：現在編集中のページID
    autoSplitEnabled?: boolean; // 🆕 自動ページ分割有効/無効
    maxCharactersPerPage?: number; // 🆕 ページ分割の閾値
  }
) => {
  // 🆕 現在のページデータ取得
  const getCurrentPageData = useCallback(async (): Promise<{
    canvasData: CanvasData;
    textContent: string;
    characterCount: number;
  }> => {
    // CanvasEditorから現在のキャンバスデータを取得
    const canvasData = getCurrentCanvasData();
    const textContent = extractTextFromCanvas(canvasData);
    
    return {
      canvasData,
      textContent,
      characterCount: textContent.length
    };
  }, []);
  
  // 🆕 自動ページ分割チェック
  const checkAutoSplit = useCallback(async (pageData: any) => {
    if (!options?.autoSplitEnabled || !options?.maxCharactersPerPage) {
      return false;
    }
    
    return pageData.characterCount > options.maxCharactersPerPage;
  }, [options]);
  
  // 🆕 ページ分割実行
  const performAutoSplit = useCallback(async (pageData: any) => {
    const splitResult = await UniversalNoteService.splitPage(
      noteId,
      options!.currentPageId,
      pageData.textContent,
      {
        maxCharactersPerPage: options!.maxCharactersPerPage!,
        splitBoundary: 'paragraph'
      }
    );
    
    console.log(`📄 自動ページ分割実行: ${splitResult.newPages.length}ページに分割`);
    return splitResult;
  }, [noteId, options]);
  
  // 🆕 複数ページ対応保存ロジック
  const performAutoSave = useCallback(async () => {
    if (isSaving) {
      console.log('🔄 保存処理中のためスキップ');
      return;
    }
    
    try {
      setIsSaving(true);
      
      // 現在のページデータを取得
      const pageData = await getCurrentPageData();
      
      // 自動ページ分割チェック
      const needsSplit = await checkAutoSplit(pageData);
      
      if (needsSplit) {
        // ページ分割実行
        const splitResult = await performAutoSplit(pageData);
        
        // 分割後の最初のページに移動
        setCurrentPageId(splitResult.newPages[0].pageId);
      } else {
        // 通常の単一ページ保存
        await UniversalNoteService.savePageOnly(
          noteId,
          options!.currentPageId,
          pageData.canvasData
        );
      }
      
      console.log('✅ 複数ページ対応自動保存完了');
      
    } catch (error) {
      console.error('❌ 自動保存エラー:', error);
    } finally {
      setIsSaving(false);
    }
  }, [noteId, options, isSaving]);
  
  // 🆕 ページ追加
  const addNewPage = useCallback(async (
    pageData?: PageCreateData
  ) => {
    const newPage = await UniversalNoteService.addPage(noteId, pageData);
    setCurrentPageId(newPage.pageId);
    console.log(`📄 新ページ追加: ${newPage.pageNumber}ページ目`);
    return newPage;
  }, [noteId]);
  
  // 🆕 ページ移動
  const navigateToPage = useCallback(async (pageNumber: number) => {
    const targetPage = await UniversalNoteService.getPageByNumber(noteId, pageNumber);
    if (targetPage) {
      setCurrentPageId(targetPage.pageId);
      console.log(`📄 ページ移動: ${pageNumber}ページ目`);
    }
  }, [noteId]);
  
  // 既存のタイマー管理ロジック
  useEffect(() => {
    const timer = setInterval(performAutoSave, AUTO_SAVE_INTERVAL);
    return () => clearInterval(timer);
  }, [performAutoSave]);
  
  return {
    performAutoSave,
    addNewPage,
    navigateToPage,
    isSaving,
    markAsChanged: () => setHasUnsavedChanges(true)
  };
};
```

#### **3. UniversalNoteService（複数ページ対応）**
```typescript
export class UniversalNoteService {
  // 🆕 ノート全体保存（複数ページ対応）
  static async saveNote(note: UniversalNote): Promise<void> {
    const operations = [];
    
    for (const page of note.pages) {
      operations.push(this.savePageOnly(note.id, page.pageId, page.canvasData));
    }
    
    // 並列保存でパフォーマンス向上
    await Promise.all(operations);
    
    // ノートメタデータ更新
    await this.updateNoteMetadata(note.id, note.metadata);
  }
  
  // 🆕 特定ページのみ保存
  static async savePageOnly(
    noteId: string, 
    pageId: string, 
    canvasData: CanvasData
  ): Promise<void> {
    const note = await this.getNote(noteId);
    
    if (note.type === 'photo_scan') {
      // SQLite: PhotoScan特定写真のcanvasData更新
      await database.updatePhotoScanPage(noteId, pageId, canvasData);
    } else {
      // PostgreSQL: pages テーブル更新
      await pagesApi.updatePage(pageId, { canvas_data: canvasData });
    }
    
    console.log(`✅ ページ保存完了: ${pageId}`);
  }
  
  // 🆕 自動ページ分割
  static async splitPage(
    noteId: string,
    pageId: string,
    textContent: string,
    config: AutoSplitConfig
  ): Promise<{
    originalPage: UniversalNote['pages'][0];
    newPages: UniversalNote['pages'];
  }> {
    // テキストを指定境界で分割
    const splitTexts = this.splitTextByBoundary(textContent, config);
    
    const note = await this.getNote(noteId);
    const originalPageIndex = note.pages.findIndex(p => p.pageId === pageId);
    const originalPage = note.pages[originalPageIndex];
    
    // 新しいページを作成
    const newPages = splitTexts.map((text, index) => ({
      pageId: `${pageId}_split_${index + 1}`,
      pageNumber: originalPage.pageNumber + index,
      canvasData: this.textToCanvasData(text),
      lastModified: new Date().toISOString(),
      pageMetadata: {
        ...originalPage.pageMetadata,
        isAutoSplit: true,
        originalPageId: pageId
      }
    }));
    
    // データベース更新
    await this.replacePageWithMultiple(noteId, pageId, newPages);
    
    return { originalPage, newPages };
  }
  
  // 🆕 ページ追加
  static async addPage(
    noteId: string, 
    pageData?: PageCreateData
  ): Promise<UniversalNote['pages'][0]> {
    const note = await this.getNote(noteId);
    
    const newPage: UniversalNote['pages'][0] = {
      pageId: generateUUID(),
      pageNumber: pageData?.pageNumber || note.pages.length + 1,
      canvasData: pageData?.canvasData || this.getEmptyCanvasData(),
      lastModified: new Date().toISOString(),
      pageMetadata: pageData?.pageMetadata
    };
    
    // ページ番号調整（既存ページの番号をシフト）
    if (pageData?.pageNumber && pageData.pageNumber <= note.pages.length) {
      await this.shiftPageNumbers(noteId, pageData.pageNumber, 1);
    }
    
    // データベースに追加
    await this.insertPage(noteId, newPage);
    
    return newPage;
  }
  
  // 🆕 ページ番号によるページ取得
  static async getPageByNumber(
    noteId: string, 
    pageNumber: number
  ): Promise<UniversalNote['pages'][0] | null> {
    const note = await this.getNote(noteId);
    return note.pages.find(p => p.pageNumber === pageNumber) || null;
  }
  
  // 🆕 大容量コンテンツの自動分割
  static async createNoteFromLargeContent(
    type: NoteType,
    title: string,
    content: string | Array<{ content: string; metadata?: any }>
  ): Promise<UniversalNote> {
    const noteId = generateUUID();
    
    let pages: UniversalNote['pages'];
    
    if (Array.isArray(content)) {
      // 既に分割済みコンテンツ（PDF各ページ、写真各枚など）
      pages = content.map((item, index) => ({
        pageId: generateUUID(),
        pageNumber: index + 1,
        canvasData: this.textToCanvasData(item.content),
        lastModified: new Date().toISOString(),
        pageMetadata: item.metadata
      }));
    } else {
      // 単一の大容量コンテンツ（90分録音文字起こしなど）
      const splitTexts = this.splitTextByBoundary(content, {
        enabled: true,
        maxCharactersPerPage: 2000,
        splitBoundary: 'paragraph',
        preserveStructure: true
      });
      
      pages = splitTexts.map((text, index) => ({
        pageId: generateUUID(),
        pageNumber: index + 1,
        canvasData: this.textToCanvasData(text),
        lastModified: new Date().toISOString(),
        pageMetadata: {
          isAutoGenerated: true,
          sourceType: type
        }
      }));
    }
    
    const note: UniversalNote = {
      id: noteId,
      type,
      title,
      pages,
      currentPage: {
        pageId: pages[0].pageId,
        pageNumber: 1
      },
      metadata: {
        totalPages: pages.length,
        autoSplitEnabled: true,
        maxCharactersPerPage: 2000,
        created_at: new Date().toISOString(),
        note_type: type
      },
      lastModified: new Date().toISOString()
    };
    
    await this.saveNote(note);
    return note;
  }
  
  // 🆕 レガシーデータ変換（既存のsingle-pageノート → multi-pageノート）
  static async convertLegacyNote(legacyNoteId: string): Promise<UniversalNote> {
    // 既存のCanvasEditorデータを取得
    const legacyData = await database.getNote(legacyNoteId);
    
    // 新しい複数ページ形式に変換
    const convertedNote: UniversalNote = {
      id: legacyNoteId,
      type: legacyData.note_type,
      title: legacyData.title,
      pages: [{
        pageId: generateUUID(),
        pageNumber: 1,
        canvasData: legacyData.canvas_data,
        lastModified: legacyData.updated_at,
        pageMetadata: {
          isLegacyConversion: true
        }
      }],
      currentPage: {
        pageId: legacyData.pageId,
        pageNumber: 1
      },
      metadata: {
        totalPages: 1,
        autoSplitEnabled: false,
        created_at: legacyData.created_at,
        note_type: legacyData.note_type
      },
      lastModified: legacyData.updated_at
    };
    
    return convertedNote;
  }
}
```

### 段階的移行戦略

#### **⚠️ 設計変更: 最初から複数ページ対応**

**理由**: 全ノートタイプで複数ページが必要
- **録音**: 90分 → 7〜9ページの文字起こし
- **インポート**: PDF 20ページ、YouTube 1時間 → 複数ページ
- **手動**: 長時間作成 → 複数ページ
- **写真スキャン**: 複数枚 → 複数ページ

#### **Phase 4.1-4.4: 複数ページ対応統一自動保存**
- **最初から複数ページ対応**で実装
- 単一ページは「1ページのみの複数ページノート」として扱う
- 全ノートタイプで統一されたページ管理

#### **Phase 5: ページナビゲーション機能**
- CanvasEditorにページ切り替えUI追加
- 自動ページ分割ロジック実装
- ページ間移動とキャンバス同期

#### **Phase 6: データ移行**
- SQLite PhotoScan → PostgreSQL Pages 自動変換
- 既存自動保存機能は無停止で継続

### 後方互換性保証

✅ **既存のCanvasEditor**: 単一ページモードで動作継続
✅ **既存の自動保存**: 変更なしで動作継続
✅ **既存のPhotoScan**: 自動変換で新形式対応
✅ **新機能追加**: デコレータパターンで自動継承

---

## 📊 **AI統合後の完全保存システム**

### 保存対象の完全カバレッジ

**100% ツールバー機能 + AI機能**:

#### **ペンツール（7機能）** → 全て`markAsChanged()`連携済み
1. ペンと鉛筆の切り替えと描画
2. 消しゴム
3. マーカー
4. メディアアップロード（画像アップロードと挿入）
5. 定規機能
6. リーディングルーラー機能
7. ペンの太さと色の変更

#### **キーボードツール（7機能）** → 全て`markAsChanged()`連携済み
1. 入力
2. 見出し1、2、3、本文変更
3. フォント変更
4. サイズ変更
5. 太文字
6. 行間変更
7. 文字間の間隔変更

#### **その他ツール（4機能）** → 全て`markAsChanged()`連携済み
1. 検索機能
2. 音声録音、再生、一時停止、停止
3. しおり機能
4. 設定（ページの設定や用紙デザイン変更など）

#### **AIチャット機能（7機能）** → 新規統合完了
1. 要約
2. 漢字、カタカナ、ひらがなに変換機能
3. 辞書
4. 校正
5. ふりがなを振る機能
6. リサーチ機能
7. 通常チャットと音声入力対応

**合計: 25機能すべてで確実な自動保存保証**

**全ノートタイプ対応**:
- ✅ recording（録音ノート） → `Canvas data updated successfully (recording)`
- ✅ photo_scan（写真スキャン） → `Canvas data updated successfully (photo scan)`  
- ✅ import（インポート） → `Canvas data updated successfully (import)`
- ✅ manual（手動作成） → `Canvas data updated successfully (manual)`

### 統合システムの信頼性指標

**パフォーマンス**:
- 🎯 保存レスポンス: <100ms（AI処理含む）
- 🎯 自動保存間隔: 5秒（設定可能）
- 🎯 AI処理時間: <3秒（要約・校正）

**信頼性**:
- 🎯 保存成功率: 99.9%（3段階リトライ）
- 🎯 データ整合性: 100%（Undo/Redo完全対応）
- 🎯 競合防止: 100%（isSaving + isAIProcessing フラグ）

---

## 🎯 **Phase 4実装完了時の達成状態**

**✅ 問題解決完了**:
1. **録音ノート**: ペンツール・テキスト以外の機能でも100%自動保存
2. **写真スキャンノート**: 全てのツールバー機能で100%自動保存  
3. **AI機能**: 要約・校正・変換等の結果も確実に自動保存
4. **新機能対応**: TTS・メディアアップロード・定規機能も自動継承

**✅ 開発効率向上**:
- 新機能追加時の自動保存コードが不要（デコレータで自動適用）
- テストケースの自動生成（104項目 → 1時間で完了）
- バグ発生率の大幅削減（手動保存コードの排除）

**✅ ユーザー体験向上**:
- データ損失リスク: 0%（100%自動保存保証）
- 操作遅延: 0ms（非同期保存）
- 学習障害児対応: 完璧（中断なし学習環境）
